# 六大设计原则

## 单一职责原则(Single Responsibility Principle)

> 定义: 应该有且仅有一个原因引起类的变更

- 什么是类的职责

- 怎么划分类的职责

## 里氏替换原则(Liskov Substitution Principle)

> 定义: 所有引用基类的地方必须能透明地使用其子类的对象

- 子类必须完全实现父类的方法

    > Notes: 在类中调用其他类时务必使用父类或接口  
    > Notes: 如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生了“畸变”，则建议采用 **依赖** ，**聚集**, **组合** 等关系代替继承

- 子类可以有自己的个性

- 覆盖或实现父类的方法时输入参数可以被放大

- 覆写或实现父类的方法时输出结果可以被缩小

## 依赖倒置原则(Dependence Inversion Principle)

> 定义: 高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象

### 对象的依赖关系传递

- 构造函数传递依赖对象

- Setter方法传递依赖对象

- 接口声明依赖对象

### 最佳实践

- 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备

- 变量的表面类型尽量是接口或抽象类

- 任何类都不应该从具体类派生

- 尽量不要覆写基类的方法

- 结合LSP使用

## 接口隔离原则

> 定义: 建立单一的接口，不要建立臃肿庞大的接口，接口尽量细化

- 接口要尽量小

- 接口要高内聚

- 定制化服务

- 接口设计是有限度的

### 最佳实践

- 一个接口只服务一个子模块或业务逻辑

- 通过业务逻辑压缩接口中的public方法

- 已经被污染了的接口，尽量去修改，若变更风险较大，则采用适配器模式进行转化处理

- 了解环境，拒绝盲从，从具体实际业务场景考虑

## 迪米特法则(Law of Demeter) or 最少知识原则(Least Knowledge Principle)

> 定义: 一个对象对其他对象应该有最少的了解，类间解耦，弱耦合

- 只和直接的"朋友"进行通信

- "朋友"之间是有距离的，不要把过多的方法暴露出去

- 是自己的就是自己的，如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中

- 谨慎使用Serializable

## 开闭原则

> 定义: 对扩展开放，对修改关闭

- 抽象约束

  - 通过接口或抽象类约束扩展

  - 参数类型，引用对象尽量使用接口或抽象类，而不是实现类

  - 抽象层尽量保持稳定

- 元数据控制模块行为

- 制定项目章程

- 封装变化
